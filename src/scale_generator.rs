const SHARPS: &[&str] = &[
    "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B",
];
const FLATS: &[&str] = &[
    "C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B",
];

#[derive(Debug)]
pub enum Error {
    InvalidTonic,
    InvalidInterval,
}

pub struct Scale {
    notes: Vec<String>,
}

impl Scale {
    pub fn new(tonic: &str, intervals: &str) -> Result<Scale, Error> {
        let chromatic_scale = match tonic {
            "C" | "a" | "G" | "D" | "A" | "E" | "B" | "F#" | "e" | "b" | "f#" | "c#" | "g#"
            | "d#" => SHARPS,
            "F" | "Bb" | "Eb" | "Ab" | "Db" | "Gb" | "d" | "g" | "c" | "f" | "bb" | "eb" => FLATS,
            _ => return Err(Error::InvalidTonic),
        };

        let mut pos = chromatic_scale
            .iter()
            .position(|&n| n.to_uppercase() == tonic.to_uppercase())
            .unwrap();
        let mut notes = vec![chromatic_scale[pos].to_string()];

        for interval in intervals.chars() {
            pos += match interval {
                'm' => 1,
                'M' => 2,
                'A' => 3,
                _ => return Err(Error::InvalidInterval),
            };

            notes.push(chromatic_scale[pos % chromatic_scale.len()].to_string());
        }

        Ok(Self { notes })
    }

    pub fn chromatic(tonic: &str) -> Result<Scale, Error> {
        Self::new(tonic, "mmmmmmmmmmmm")
    }

    pub fn enumerate(&self) -> Vec<String> {
        self.notes.clone()
    }
}

#[cfg(test)]
mod tests {
    //! Tests for scale-generator

    //!

    //! Generated by [script][script] using [canonical data][canonical-data]

    //!

    //! [script]: https://github.com/exercism/rust/blob/main/bin/init_exercise.py

    //! [canonical-data]: https://raw.githubusercontent.com/exercism/problem-specifications/main/exercises/scale-generator/canonical_data.json

    use crate::scale_generator::*;

    /// Process a single test case for the property `chromatic`

    ///

    /// All cases for the `chromatic` property are implemented

    /// in terms of this function.

    fn process_chromatic_case(tonic: &str, expected: &[&str]) {
        let s = Scale::chromatic(tonic).unwrap();

        assert_eq!(s.enumerate(), expected);
    }

    /// Process a single test case for the property `interval`

    ///

    /// All cases for the `interval` property are implemented

    /// in terms of this function.

    fn process_interval_case(tonic: &str, intervals: &str, expected: &[&str]) {
        let s = Scale::new(tonic, intervals).unwrap();

        assert_eq!(s.enumerate(), expected);
    }

    // Chromatic scales

    // These tests have no interval.

    // The chromatic scale is considered the default scale

    #[test]
    fn test_chromatic_scale_with_sharps() {
        process_chromatic_case(
            "C",
            &[
                "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B", "C",
            ],
        );
    }

    #[test]
    fn test_chromatic_scale_with_flats() {
        process_chromatic_case(
            "F",
            &[
                "F", "Gb", "G", "Ab", "A", "Bb", "B", "C", "Db", "D", "Eb", "E", "F",
            ],
        );
    }

    #[test]
    fn test_simple_major_scale() {
        process_interval_case("C", "MMmMMMm", &["C", "D", "E", "F", "G", "A", "B", "C"]);
    }

    #[test]
    fn test_major_scale_with_sharps() {
        process_interval_case("G", "MMmMMMm", &["G", "A", "B", "C", "D", "E", "F#", "G"]);
    }

    #[test]
    fn test_major_scale_with_flats() {
        process_interval_case("F", "MMmMMMm", &["F", "G", "A", "Bb", "C", "D", "E", "F"]);
    }

    #[test]
    fn test_minor_scale_with_sharps() {
        process_interval_case(
            "f#",
            "MmMMmMM",
            &["F#", "G#", "A", "B", "C#", "D", "E", "F#"],
        );
    }

    #[test]
    fn test_minor_scale_with_flats() {
        process_interval_case(
            "bb",
            "MmMMmMM",
            &["Bb", "C", "Db", "Eb", "F", "Gb", "Ab", "Bb"],
        );
    }

    #[test]
    fn test_dorian_mode() {
        process_interval_case("d", "MmMMMmM", &["D", "E", "F", "G", "A", "B", "C", "D"]);
    }

    #[test]
    fn test_mixolydian_mode() {
        process_interval_case(
            "Eb",
            "MMmMMmM",
            &["Eb", "F", "G", "Ab", "Bb", "C", "Db", "Eb"],
        );
    }

    #[test]
    fn test_lydian_mode() {
        process_interval_case(
            "a",
            "MMMmMMm",
            &["A", "B", "C#", "D#", "E", "F#", "G#", "A"],
        );
    }

    #[test]
    fn test_phrygian_mode() {
        process_interval_case("e", "mMMMmMM", &["E", "F", "G", "A", "B", "C", "D", "E"]);
    }

    #[test]
    fn test_locrian_mode() {
        process_interval_case(
            "g",
            "mMMmMMM",
            &["G", "Ab", "Bb", "C", "Db", "Eb", "F", "G"],
        );
    }

    #[test]
    fn test_harmonic_minor() {
        process_interval_case("d", "MmMMmAm", &["D", "E", "F", "G", "A", "Bb", "Db", "D"]);
    }

    #[test]
    fn test_octatonic() {
        process_interval_case(
            "C",
            "MmMmMmMm",
            &["C", "D", "D#", "F", "F#", "G#", "A", "B", "C"],
        );
    }

    #[test]
    fn test_hexatonic() {
        process_interval_case("Db", "MMMMMM", &["Db", "Eb", "F", "G", "A", "B", "Db"]);
    }

    #[test]
    fn test_pentatonic() {
        process_interval_case("A", "MMAMA", &["A", "B", "C#", "E", "F#", "A"]);
    }

    #[test]
    fn test_enigmatic() {
        process_interval_case(
            "G",
            "mAMMMmm",
            &["G", "G#", "B", "C#", "D#", "F", "F#", "G"],
        );
    }
}
